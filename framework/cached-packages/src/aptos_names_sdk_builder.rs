// Copyright (c) Aptos
// SPDX-License-Identifier: Apache-2.0

// This file was generated. Do not modify!
//
// To update this code, run: `cargo run --release -p framework`.

// Conversion library between a structured representation of a Move script call (`ScriptCall`) and the
// standard BCS-compatible representation used in Aptos transactions (`Script`).
//
// This code was generated by compiling known Script interfaces ("ABIs") with the tool `aptos-sdk-builder`.

#![allow(dead_code)]
#![allow(unused_imports)]
use aptos_types::{
    account_address::AccountAddress,
    transaction::{EntryFunction, TransactionPayload},
};
use move_core_types::{
    ident_str,
    language_storage::{ModuleId, TypeTag},
};

type Bytes = Vec<u8>;

/// Structured representation of a call into a known Move entry function.
/// ```ignore
/// impl EntryFunctionCall {
///     pub fn encode(self) -> TransactionPayload { .. }
///     pub fn decode(&TransactionPayload) -> Option<EntryFunctionCall> { .. }
/// }
/// ```
#[derive(Clone, Debug, PartialEq, Eq)]
#[cfg_attr(feature = "fuzzing", derive(proptest_derive::Arbitrary))]
#[cfg_attr(feature = "fuzzing", proptest(no_params))]
pub enum EntryFunctionCall {
    ConfigSetAdminAddress {
        addr: AccountAddress,
    },

    ConfigSetDomainPriceForLength {
        price: u64,
        length: u64,
    },

    ConfigSetFoundationFundAddress {
        addr: AccountAddress,
    },

    ConfigSetIsEnabled {
        enabled: bool,
    },

    ConfigSetMaxDomainLength {
        domain_length: u64,
    },

    ConfigSetMaxNumberOfYearsRegistered {
        max_years_registered: u8,
    },

    ConfigSetSubdomainPrice {
        price: u64,
    },

    ConfigSetTokendataDescription {
        description: Vec<u8>,
    },

    ConfigSetTokendataUrlPrefix {
        description: Vec<u8>,
    },

    DomainsClearDomainAddress {
        domain_name: Vec<u8>,
    },

    DomainsClearSubdomainAddress {
        subdomain_name: Vec<u8>,
        domain_name: Vec<u8>,
    },

    /// Forcefully create or seize a domain name. This is a privileged operation, used via governance.
    /// This can be used, for example, to forcefully create a domain for a system address domain, or to seize a domain from a malicious user.
    /// The `registration_duration_secs` parameter is the number of seconds to register the domain for, but is not limited to the maximum set in the config for domains registered normally.
    /// This allows, for example, to create a domain for the system address for 100 years so we don't need to worry about expiry
    /// Or for moderation purposes, it allows us to seize a racist/harassing domain for 100 years, and park it somewhere safe
    DomainsForceCreateOrSeizeDomainName {
        domain_name: Vec<u8>,
        registration_duration_secs: u64,
    },

    DomainsForceCreateOrSeizeSubdomainName {
        subdomain_name: Vec<u8>,
        domain_name: Vec<u8>,
        registration_duration_secs: u64,
    },

    /// Forcefully set the name of a domain.
    /// This is a privileged operation, used via governance, to forcefully set a domain address
    /// This can be used, for example, to forcefully set the domain for a system address domain
    DomainsForceSetDomainAddress {
        domain_name: Vec<u8>,
        new_owner: AccountAddress,
    },

    DomainsForceSetSubdomainAddress {
        subdomain_name: Vec<u8>,
        domain_name: Vec<u8>,
        new_owner: AccountAddress,
    },

    /// This is only callable during genesis or framework upgrades
    DomainsInitialize {
        funds_address: AccountAddress,
        admin_address: AccountAddress,
    },

    /// A wrapper around `register_name` as an entry function.
    /// Option<String> is not currently serializable, so we have these convenience methods
    DomainsRegisterDomain {
        domain_name: Vec<u8>,
        num_years: u8,
    },

    /// A wrapper around `register_name` as an entry function.
    /// Option<String> is not currently serializable, so we have these convenience method
    DomainsRegisterSubdomain {
        subdomain_name: Vec<u8>,
        domain_name: Vec<u8>,
        registration_duration_secs: u64,
    },

    DomainsSetDomainAddress {
        domain_name: Vec<u8>,
        new_address: AccountAddress,
    },

    DomainsSetSubdomainAddress {
        subdomain_name: Vec<u8>,
        domain_name: Vec<u8>,
        new_address: AccountAddress,
    },
}

impl EntryFunctionCall {
    /// Build an Aptos `TransactionPayload` from a structured object `EntryFunctionCall`.
    pub fn encode(self) -> TransactionPayload {
        use EntryFunctionCall::*;
        match self {
            ConfigSetAdminAddress { addr } => config_set_admin_address(addr),
            ConfigSetDomainPriceForLength { price, length } => {
                config_set_domain_price_for_length(price, length)
            }
            ConfigSetFoundationFundAddress { addr } => config_set_foundation_fund_address(addr),
            ConfigSetIsEnabled { enabled } => config_set_is_enabled(enabled),
            ConfigSetMaxDomainLength { domain_length } => {
                config_set_max_domain_length(domain_length)
            }
            ConfigSetMaxNumberOfYearsRegistered {
                max_years_registered,
            } => config_set_max_number_of_years_registered(max_years_registered),
            ConfigSetSubdomainPrice { price } => config_set_subdomain_price(price),
            ConfigSetTokendataDescription { description } => {
                config_set_tokendata_description(description)
            }
            ConfigSetTokendataUrlPrefix { description } => {
                config_set_tokendata_url_prefix(description)
            }
            DomainsClearDomainAddress { domain_name } => domains_clear_domain_address(domain_name),
            DomainsClearSubdomainAddress {
                subdomain_name,
                domain_name,
            } => domains_clear_subdomain_address(subdomain_name, domain_name),
            DomainsForceCreateOrSeizeDomainName {
                domain_name,
                registration_duration_secs,
            } => domains_force_create_or_seize_domain_name(domain_name, registration_duration_secs),
            DomainsForceCreateOrSeizeSubdomainName {
                subdomain_name,
                domain_name,
                registration_duration_secs,
            } => domains_force_create_or_seize_subdomain_name(
                subdomain_name,
                domain_name,
                registration_duration_secs,
            ),
            DomainsForceSetDomainAddress {
                domain_name,
                new_owner,
            } => domains_force_set_domain_address(domain_name, new_owner),
            DomainsForceSetSubdomainAddress {
                subdomain_name,
                domain_name,
                new_owner,
            } => domains_force_set_subdomain_address(subdomain_name, domain_name, new_owner),
            DomainsInitialize {
                funds_address,
                admin_address,
            } => domains_initialize(funds_address, admin_address),
            DomainsRegisterDomain {
                domain_name,
                num_years,
            } => domains_register_domain(domain_name, num_years),
            DomainsRegisterSubdomain {
                subdomain_name,
                domain_name,
                registration_duration_secs,
            } => {
                domains_register_subdomain(subdomain_name, domain_name, registration_duration_secs)
            }
            DomainsSetDomainAddress {
                domain_name,
                new_address,
            } => domains_set_domain_address(domain_name, new_address),
            DomainsSetSubdomainAddress {
                subdomain_name,
                domain_name,
                new_address,
            } => domains_set_subdomain_address(subdomain_name, domain_name, new_address),
        }
    }

    /// Try to recognize an Aptos `TransactionPayload` and convert it into a structured object `EntryFunctionCall`.
    pub fn decode(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            match SCRIPT_FUNCTION_DECODER_MAP.get(&format!(
                "{}_{}",
                script.module().name(),
                script.function()
            )) {
                Some(decoder) => decoder(payload),
                None => None,
            }
        } else {
            None
        }
    }
}

pub fn config_set_admin_address(addr: AccountAddress) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 4,
            ]),
            ident_str!("config").to_owned(),
        ),
        ident_str!("set_admin_address").to_owned(),
        vec![],
        vec![bcs::to_bytes(&addr).unwrap()],
    ))
}

pub fn config_set_domain_price_for_length(price: u64, length: u64) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 4,
            ]),
            ident_str!("config").to_owned(),
        ),
        ident_str!("set_domain_price_for_length").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&price).unwrap(),
            bcs::to_bytes(&length).unwrap(),
        ],
    ))
}

pub fn config_set_foundation_fund_address(addr: AccountAddress) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 4,
            ]),
            ident_str!("config").to_owned(),
        ),
        ident_str!("set_foundation_fund_address").to_owned(),
        vec![],
        vec![bcs::to_bytes(&addr).unwrap()],
    ))
}

pub fn config_set_is_enabled(enabled: bool) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 4,
            ]),
            ident_str!("config").to_owned(),
        ),
        ident_str!("set_is_enabled").to_owned(),
        vec![],
        vec![bcs::to_bytes(&enabled).unwrap()],
    ))
}

pub fn config_set_max_domain_length(domain_length: u64) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 4,
            ]),
            ident_str!("config").to_owned(),
        ),
        ident_str!("set_max_domain_length").to_owned(),
        vec![],
        vec![bcs::to_bytes(&domain_length).unwrap()],
    ))
}

pub fn config_set_max_number_of_years_registered(max_years_registered: u8) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 4,
            ]),
            ident_str!("config").to_owned(),
        ),
        ident_str!("set_max_number_of_years_registered").to_owned(),
        vec![],
        vec![bcs::to_bytes(&max_years_registered).unwrap()],
    ))
}

pub fn config_set_subdomain_price(price: u64) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 4,
            ]),
            ident_str!("config").to_owned(),
        ),
        ident_str!("set_subdomain_price").to_owned(),
        vec![],
        vec![bcs::to_bytes(&price).unwrap()],
    ))
}

pub fn config_set_tokendata_description(description: Vec<u8>) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 4,
            ]),
            ident_str!("config").to_owned(),
        ),
        ident_str!("set_tokendata_description").to_owned(),
        vec![],
        vec![bcs::to_bytes(&description).unwrap()],
    ))
}

pub fn config_set_tokendata_url_prefix(description: Vec<u8>) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 4,
            ]),
            ident_str!("config").to_owned(),
        ),
        ident_str!("set_tokendata_url_prefix").to_owned(),
        vec![],
        vec![bcs::to_bytes(&description).unwrap()],
    ))
}

pub fn domains_clear_domain_address(domain_name: Vec<u8>) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 4,
            ]),
            ident_str!("domains").to_owned(),
        ),
        ident_str!("clear_domain_address").to_owned(),
        vec![],
        vec![bcs::to_bytes(&domain_name).unwrap()],
    ))
}

pub fn domains_clear_subdomain_address(
    subdomain_name: Vec<u8>,
    domain_name: Vec<u8>,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 4,
            ]),
            ident_str!("domains").to_owned(),
        ),
        ident_str!("clear_subdomain_address").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&subdomain_name).unwrap(),
            bcs::to_bytes(&domain_name).unwrap(),
        ],
    ))
}

/// Forcefully create or seize a domain name. This is a privileged operation, used via governance.
/// This can be used, for example, to forcefully create a domain for a system address domain, or to seize a domain from a malicious user.
/// The `registration_duration_secs` parameter is the number of seconds to register the domain for, but is not limited to the maximum set in the config for domains registered normally.
/// This allows, for example, to create a domain for the system address for 100 years so we don't need to worry about expiry
/// Or for moderation purposes, it allows us to seize a racist/harassing domain for 100 years, and park it somewhere safe
pub fn domains_force_create_or_seize_domain_name(
    domain_name: Vec<u8>,
    registration_duration_secs: u64,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 4,
            ]),
            ident_str!("domains").to_owned(),
        ),
        ident_str!("force_create_or_seize_domain_name").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&domain_name).unwrap(),
            bcs::to_bytes(&registration_duration_secs).unwrap(),
        ],
    ))
}

pub fn domains_force_create_or_seize_subdomain_name(
    subdomain_name: Vec<u8>,
    domain_name: Vec<u8>,
    registration_duration_secs: u64,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 4,
            ]),
            ident_str!("domains").to_owned(),
        ),
        ident_str!("force_create_or_seize_subdomain_name").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&subdomain_name).unwrap(),
            bcs::to_bytes(&domain_name).unwrap(),
            bcs::to_bytes(&registration_duration_secs).unwrap(),
        ],
    ))
}

/// Forcefully set the name of a domain.
/// This is a privileged operation, used via governance, to forcefully set a domain address
/// This can be used, for example, to forcefully set the domain for a system address domain
pub fn domains_force_set_domain_address(
    domain_name: Vec<u8>,
    new_owner: AccountAddress,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 4,
            ]),
            ident_str!("domains").to_owned(),
        ),
        ident_str!("force_set_domain_address").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&domain_name).unwrap(),
            bcs::to_bytes(&new_owner).unwrap(),
        ],
    ))
}

pub fn domains_force_set_subdomain_address(
    subdomain_name: Vec<u8>,
    domain_name: Vec<u8>,
    new_owner: AccountAddress,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 4,
            ]),
            ident_str!("domains").to_owned(),
        ),
        ident_str!("force_set_subdomain_address").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&subdomain_name).unwrap(),
            bcs::to_bytes(&domain_name).unwrap(),
            bcs::to_bytes(&new_owner).unwrap(),
        ],
    ))
}

/// This is only callable during genesis or framework upgrades
pub fn domains_initialize(
    funds_address: AccountAddress,
    admin_address: AccountAddress,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 4,
            ]),
            ident_str!("domains").to_owned(),
        ),
        ident_str!("initialize").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&funds_address).unwrap(),
            bcs::to_bytes(&admin_address).unwrap(),
        ],
    ))
}

/// A wrapper around `register_name` as an entry function.
/// Option<String> is not currently serializable, so we have these convenience methods
pub fn domains_register_domain(domain_name: Vec<u8>, num_years: u8) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 4,
            ]),
            ident_str!("domains").to_owned(),
        ),
        ident_str!("register_domain").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&domain_name).unwrap(),
            bcs::to_bytes(&num_years).unwrap(),
        ],
    ))
}

/// A wrapper around `register_name` as an entry function.
/// Option<String> is not currently serializable, so we have these convenience method
pub fn domains_register_subdomain(
    subdomain_name: Vec<u8>,
    domain_name: Vec<u8>,
    registration_duration_secs: u64,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 4,
            ]),
            ident_str!("domains").to_owned(),
        ),
        ident_str!("register_subdomain").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&subdomain_name).unwrap(),
            bcs::to_bytes(&domain_name).unwrap(),
            bcs::to_bytes(&registration_duration_secs).unwrap(),
        ],
    ))
}

pub fn domains_set_domain_address(
    domain_name: Vec<u8>,
    new_address: AccountAddress,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 4,
            ]),
            ident_str!("domains").to_owned(),
        ),
        ident_str!("set_domain_address").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&domain_name).unwrap(),
            bcs::to_bytes(&new_address).unwrap(),
        ],
    ))
}

pub fn domains_set_subdomain_address(
    subdomain_name: Vec<u8>,
    domain_name: Vec<u8>,
    new_address: AccountAddress,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 4,
            ]),
            ident_str!("domains").to_owned(),
        ),
        ident_str!("set_subdomain_address").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&subdomain_name).unwrap(),
            bcs::to_bytes(&domain_name).unwrap(),
            bcs::to_bytes(&new_address).unwrap(),
        ],
    ))
}
mod decoder {
    use super::*;
    pub fn config_set_admin_address(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::ConfigSetAdminAddress {
                addr: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn config_set_domain_price_for_length(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::ConfigSetDomainPriceForLength {
                price: bcs::from_bytes(script.args().get(0)?).ok()?,
                length: bcs::from_bytes(script.args().get(1)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn config_set_foundation_fund_address(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::ConfigSetFoundationFundAddress {
                addr: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn config_set_is_enabled(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::ConfigSetIsEnabled {
                enabled: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn config_set_max_domain_length(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::ConfigSetMaxDomainLength {
                domain_length: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn config_set_max_number_of_years_registered(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::ConfigSetMaxNumberOfYearsRegistered {
                max_years_registered: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn config_set_subdomain_price(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::ConfigSetSubdomainPrice {
                price: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn config_set_tokendata_description(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::ConfigSetTokendataDescription {
                description: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn config_set_tokendata_url_prefix(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::ConfigSetTokendataUrlPrefix {
                description: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn domains_clear_domain_address(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::DomainsClearDomainAddress {
                domain_name: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn domains_clear_subdomain_address(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::DomainsClearSubdomainAddress {
                subdomain_name: bcs::from_bytes(script.args().get(0)?).ok()?,
                domain_name: bcs::from_bytes(script.args().get(1)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn domains_force_create_or_seize_domain_name(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::DomainsForceCreateOrSeizeDomainName {
                domain_name: bcs::from_bytes(script.args().get(0)?).ok()?,
                registration_duration_secs: bcs::from_bytes(script.args().get(1)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn domains_force_create_or_seize_subdomain_name(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::DomainsForceCreateOrSeizeSubdomainName {
                subdomain_name: bcs::from_bytes(script.args().get(0)?).ok()?,
                domain_name: bcs::from_bytes(script.args().get(1)?).ok()?,
                registration_duration_secs: bcs::from_bytes(script.args().get(2)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn domains_force_set_domain_address(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::DomainsForceSetDomainAddress {
                domain_name: bcs::from_bytes(script.args().get(0)?).ok()?,
                new_owner: bcs::from_bytes(script.args().get(1)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn domains_force_set_subdomain_address(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::DomainsForceSetSubdomainAddress {
                subdomain_name: bcs::from_bytes(script.args().get(0)?).ok()?,
                domain_name: bcs::from_bytes(script.args().get(1)?).ok()?,
                new_owner: bcs::from_bytes(script.args().get(2)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn domains_initialize(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::DomainsInitialize {
                funds_address: bcs::from_bytes(script.args().get(0)?).ok()?,
                admin_address: bcs::from_bytes(script.args().get(1)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn domains_register_domain(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::DomainsRegisterDomain {
                domain_name: bcs::from_bytes(script.args().get(0)?).ok()?,
                num_years: bcs::from_bytes(script.args().get(1)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn domains_register_subdomain(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::DomainsRegisterSubdomain {
                subdomain_name: bcs::from_bytes(script.args().get(0)?).ok()?,
                domain_name: bcs::from_bytes(script.args().get(1)?).ok()?,
                registration_duration_secs: bcs::from_bytes(script.args().get(2)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn domains_set_domain_address(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::DomainsSetDomainAddress {
                domain_name: bcs::from_bytes(script.args().get(0)?).ok()?,
                new_address: bcs::from_bytes(script.args().get(1)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn domains_set_subdomain_address(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::DomainsSetSubdomainAddress {
                subdomain_name: bcs::from_bytes(script.args().get(0)?).ok()?,
                domain_name: bcs::from_bytes(script.args().get(1)?).ok()?,
                new_address: bcs::from_bytes(script.args().get(2)?).ok()?,
            })
        } else {
            None
        }
    }
}

type EntryFunctionDecoderMap = std::collections::HashMap<
    String,
    Box<
        dyn Fn(&TransactionPayload) -> Option<EntryFunctionCall>
            + std::marker::Sync
            + std::marker::Send,
    >,
>;

static SCRIPT_FUNCTION_DECODER_MAP: once_cell::sync::Lazy<EntryFunctionDecoderMap> =
    once_cell::sync::Lazy::new(|| {
        let mut map: EntryFunctionDecoderMap = std::collections::HashMap::new();
        map.insert(
            "config_set_admin_address".to_string(),
            Box::new(decoder::config_set_admin_address),
        );
        map.insert(
            "config_set_domain_price_for_length".to_string(),
            Box::new(decoder::config_set_domain_price_for_length),
        );
        map.insert(
            "config_set_foundation_fund_address".to_string(),
            Box::new(decoder::config_set_foundation_fund_address),
        );
        map.insert(
            "config_set_is_enabled".to_string(),
            Box::new(decoder::config_set_is_enabled),
        );
        map.insert(
            "config_set_max_domain_length".to_string(),
            Box::new(decoder::config_set_max_domain_length),
        );
        map.insert(
            "config_set_max_number_of_years_registered".to_string(),
            Box::new(decoder::config_set_max_number_of_years_registered),
        );
        map.insert(
            "config_set_subdomain_price".to_string(),
            Box::new(decoder::config_set_subdomain_price),
        );
        map.insert(
            "config_set_tokendata_description".to_string(),
            Box::new(decoder::config_set_tokendata_description),
        );
        map.insert(
            "config_set_tokendata_url_prefix".to_string(),
            Box::new(decoder::config_set_tokendata_url_prefix),
        );
        map.insert(
            "domains_clear_domain_address".to_string(),
            Box::new(decoder::domains_clear_domain_address),
        );
        map.insert(
            "domains_clear_subdomain_address".to_string(),
            Box::new(decoder::domains_clear_subdomain_address),
        );
        map.insert(
            "domains_force_create_or_seize_domain_name".to_string(),
            Box::new(decoder::domains_force_create_or_seize_domain_name),
        );
        map.insert(
            "domains_force_create_or_seize_subdomain_name".to_string(),
            Box::new(decoder::domains_force_create_or_seize_subdomain_name),
        );
        map.insert(
            "domains_force_set_domain_address".to_string(),
            Box::new(decoder::domains_force_set_domain_address),
        );
        map.insert(
            "domains_force_set_subdomain_address".to_string(),
            Box::new(decoder::domains_force_set_subdomain_address),
        );
        map.insert(
            "domains_initialize".to_string(),
            Box::new(decoder::domains_initialize),
        );
        map.insert(
            "domains_register_domain".to_string(),
            Box::new(decoder::domains_register_domain),
        );
        map.insert(
            "domains_register_subdomain".to_string(),
            Box::new(decoder::domains_register_subdomain),
        );
        map.insert(
            "domains_set_domain_address".to_string(),
            Box::new(decoder::domains_set_domain_address),
        );
        map.insert(
            "domains_set_subdomain_address".to_string(),
            Box::new(decoder::domains_set_subdomain_address),
        );
        map
    });
